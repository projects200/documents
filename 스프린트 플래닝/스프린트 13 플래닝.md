[https://app.planitpoker.com/room/xteN7A4ehw6RBqQSR0XOqurpoYcaCrsd](https://app.planitpoker.com/room/GehvOn5PIJ0d1FGcPTu6r56EaSKUIPuE)

“[역할/사용자]으로서 [행동/목표]을 하고 싶다, 그래서 [가치/이유]를 얻는다.”

### 스프린트 Velocity  : 24점

학습이 필요없는 단순한 기능 CRUD 개발 기준 : 8점 (웹+앱+백)

## 마일스톤

## 총 점수 :  24(24)점

1. 사용자로서, 앱에서 알림을 직접 켜거나 끄고 싶다. 그래서 나에게 맞는 방식으로 알림을 받을 수 있다.
    
    웹 : 10월 6일
    
    앱 : 10월 6일
    
    백 : 10월 6일
    

2.  사용자로서, 다른 사용자와 실시간으로 대화를 하고 싶다. 그래서 원활하게 소통할 수 있다

백엔드 : 10월 14일

웹 : 10월 14일

앱 : 10월 14일

- 배포일 기준이기 때문에 웹/앱 ui 개발은 더 빨리 끝날 예정
1. 사용자로서, 웹과 앱을 사용할 때 오류 없이 안정적으로 동작하길 원한다. 그래서 불편함 없이 서비스를 신뢰하고 사용할 수 있다.
    
    웹 : 10월 14일
    
    앱 : 10월 14일
    

## 스프린트 13 플래닝(18)

### 사용자로서, 다른 사용자와 실시간으로 대화를 하고 싶다. 그래서 원활하게 소통할 수 있다(10)

### 사용자로서, 웹과 앱을 사용할 때 오류 없이 안정적으로 동작하길 원한다. 그래서 불편함 없이 서비스를 신뢰하고 사용할 수 있다. (6)

### 사용자로서, 앱에서 알림을 직접 켜거나 끄고 싶다. 그래서 나에게 맞는 방식으로 알림을 받을 수 있다.(2)

### 사용자로서, 서비스가 안정적이고 빠르게 동작하길 원한다. 그래서 언제 어디서든 끊김 없이 신뢰할 수 있고 편리하게 이용할 수 있다.

1. 사용자로서, 웹과 앱을 사용할 때 오류 없이 안정적으로 동작하길 원한다. 그래서 불편함 없이 서비스를 신뢰하고 사용할 수 있다.
    1. 최초로 페이지 진입 시 로딩이 오래 걸리는 오류
    2. 캘린더 스와이프 이벤트 오류
    3. 화면 짤림 현상
2. 사용자로서, 앱에서 알림을 직접 켜거나 끄고 싶다. 그래서 나에게 맞는 방식으로 알림을 받을 수 있다.
3. 사용자로서, 페이지가 빠르게 렌더링되길 원한다. 그래서 답답함 없이 콘텐츠를 볼 수 있다.

- 사용자로서, 앱을 닫아도 타이머가 계속 동작하길 원한다. 그래서 다른 작업을 하면서도 타이머를 활용할 수 있다.
- 사용자로서, 메인 화면에서 뒤로가기 버튼을 두 번 누르면 앱이 종료되길 원한다. 그래서 자연스럽게 앱을 닫을 수 있다.
- 사용자로서, 운동기록 시 날짜 및 시간 등록을 간편하게 할 수 있다.

---

- 사용자로서, 다른 사용자가 나에게 채팅을 보냈을 때 알림을 받고 싶다. 그래서 앱을 보고 있지 않아도 새로운 메시지를 놓치지 않는다.

웹

오류

1. 최초로 페이지 진입 시 로딩이 오래 걸리는 오류
2. 캘린더 스와이프 이벤트 오류
3. 로그인 2번 해야되는 오류
4. SWR사용하여 데이터 생성,수정,삭제 시 바로 적용되지 않고 캐쉬에 있는 데이터가 보여지는 오류

추가기능

1. ios fcm관련 새로운 기기에서 로그인 했을때 알람권한 획득
    1. 서비스 설정창에 alert 온오프 기능
2. 타이머 백그라운드 동작
    - 서비스 워커 공부
3. 메인 페이지들에서 뒤로가기 2번누르면 앱 꺼지도록
4. 타임 스피너 리팩토링
5. 페이지 로드시간 개선(렌더링 성능 최적화)
- 웹 할일 목록
    1. 자동로그인

앱

1. 화면 짤림 현상
2. 설정에 알림 온오프 기능
3. 페이지 로딩 - 캐싱 & 스켈레톤
4. 바텀 네비게이션 메인 페이지들에서 뒤로가기 2번 누르면 앱 꺼지도록
5. 타임 스피너 리팩토링
6. ~~타~~이머 백그라운드
7. 앱 무결성 검사
- 앱 할일 목록
    
    

백엔드

- Polling 방식 채팅기능 개발
    - 폴링방식 기능 개발
        
        ### [공유용] Polling 방식 채팅 기능 구현 핵심 가이드
        
        안녕하세요, Polling 방식 채팅 기능 개발 관련 내용을 공유합니다.
        
        Polling은 구현이 비교적 간단하지만, 서버 부하 문제가 발생할 수 있어 효율적인 설계가 중요합니다.
        
        ### **1. Polling의 기본 개념과 종류**
        
        - **Short Polling (우리가 구현할 방식)**
            - **동작:** 클라이언트가 일정한 간격(예: 1~2초)으로 서버에 "새 메시지 있어?"라고 계속 물어보는 방식입니다.
            - **장점:** 구현이 매우 직관적이고 간단합니다.
            - **단점:** 불필요한 요청이 많아 서버와 데이터베이스에 부하를 줄 수 있습니다.
        - **Long Polling (Short Polling의 개선판)**
            - **동작:** 클라이언트가 서버에 요청을 보내면, 서버는 새 메시지가 생길 때까지 응답을 대기합니다. 새 메시지가 오거나 타임아웃이 되면 응답하고, 클라이언트는 즉시 다시 요청을 보냅니다.
            - **장점:** 불필요한 요청이 줄어들어 효율적입니다.
            - **단점:** 서버에서 연결을 유지해야 하므로 구현이 조금 더 복잡합니다.
        
        ### **2. 핵심 과제: 불필요한 서버 부하 줄이기**
        
        Polling 방식의 성공은 "어떻게 불필요한 요청을 최소화하는가"에 달려있습니다.
        
        **해결 방안 1: 클라이언트(프론트엔드)에서의 Polling 생명주기 관리 (가장 중요!)**
        
        서버는 클라이언트가 채팅창을 보고 있는지 알 수 없습니다. 따라서 Polling을 시작하고 멈추는 책임은 클라이언트에 있습니다.
        
        - **(시작) 채팅방 진입 시:** 사용자가 채팅 화면에 들어오면 setInterval 등을 이용해 Polling을 **시작**합니다.
        - **(중지) 채팅방 이탈 시:** 사용자가 뒤로 가거나 다른 화면으로 이동하면, 반드시 setInterval 타이머를 **해제(clear)**하여 Polling을 **완전히 중지**해야 합니다. (React의 useEffect cleanup 등 활용)
        - **(선택) 백그라운드 전환 시:** 앱이 백그라운드로 전환되거나 브라우저 탭이 비활성화되면 Polling을 일시 중지하거나 간격을 크게 늘려(예: 30초) 부하를 줄일 수 있습니다.
        
        > [팀 협의사항]
        > 
        > 
        > 프론트엔드에서는 사용자가 채팅방을 나갔을 때 Polling 요청이 완전히 멈추도록 구현이 필요합니다.
        > 
        
        **해결 방안 2: 서버(백엔드)에서의 DB 조회 최적화**
        
        클라이언트의 모든 Polling 요청은 DB 조회로 이어집니다. 이 비용을 최소화해야 합니다.
        
        - **API 설계:** 클라이언트는 항상 마지막으로 받은 메시지의 ID(lastMessageId)를 요청에 포함해야 합니다.
            - GET /api/chat/rooms/{roomId}/messages?lastMessageId=123
        - **효율적인 쿼리:** 서버는 받은 lastMessageId를 사용하여 "해당 ID보다 최신인 메시지"만 조회해야 합니다.
            - SELECT * FROM messages WHERE room_id = ? AND message_id > ? ORDER BY message_id ASC;
        - **DB 인덱스 생성 (필수!):** message_id 컬럼과 room_id 컬럼에는 반드시 **인덱스(Index)**를 설정해야 합니다. 인덱스가 없으면 메시지가 쌓일수록 성능이 급격히 저하됩니다.
        
        ### **3. 역할 분담 및 체크리스트**
        
        - **백엔드 (담당자: OOO)**
            
            채팅 메시지 조회 API 구현 (/api/chat/rooms/{roomId}/messages)
                    ▪ lastMessageId 쿼리 파라미터 처리 로직 포함
            
            - ▪
                
                lastMessageId 쿼리 파라미터 처리 로직 포함
                
            
            messages 테이블의 message_id, room_id 컬럼에 인덱스 생성
            
            채팅 메시지 전송 API 구현 (POST /api/chat/rooms/{roomId}/messages)
            
            채팅방 생성, 목록 조회 등 기타 API 구현
            
        - **프론트엔드 (담당자: OOO)**
            
            채팅방 진입 시 Polling 시작 로직 구현 (setInterval 등)
            
            채팅방 이탈 시 Polling 중지 로직 구현 (clearInterval 등)
            
            Polling 요청 시 lastMessageId를 동적으로 파라미터에 포함하여 전송
            
            새 메시지 수신 시 화면에 렌더링하는 로직 구현
            
        
        이 가이드를 바탕으로 효율적이고 안정적인 채팅 기능을 만들어가면 좋겠습니다.
        
- 알림 기능 개발
- 백엔드 할 일 목록
    - 채팅기능 개발
        - Polling <<< 디비에 채팅 다 저장 (어렵지않다고 윤재씨가)
            - 1초? 2초마다 계속 GET GET GET GET GET GET GET GET GET GET GET GET GET GET
        - Stomp
            - 우리가 진짜 쓰는 채팅앱 소켓 + 메시지 큐 …. ~~~~
    - 회원탈퇴시 …. (작게 잡아서)
        - 디비에서 회원에 is_deleted = localdatetime.now() 만 넣어주고, 코그니토에서는 수동으로 지워준다?
    - 카카오 로컬 api 연동
        - https://developers.kakao.com/docs/latest/ko/local/common
    - 썸네일 이미지 생성
    - 차단기능 개발
    - 매칭 기능 어떻게 저장할 것인지?

---

### 이전 플래닝 목록

### 0. 사용자는 마이페이지에서 내가 선호하는 운동과 각 수준, 요일을 등록할 수 있다. (12)

- 백엔드 (6)
    1. 선택가능한 선호 운동 종류 조회 API / 선택 화면
        1. 운동 종류
        2. 운동 주기
        3. 운동 수준
    
    1. 선호 운동 리스트 추가
    2. 선호 운동 리스트 수정
    3. 선호 운동 리스트 삭제 
    4. 썸네일 리사이징 및 생성/삭제
        1. 썸네일 생성
        2. 썸네일 삭제
- 클라이언트 (6)
    1. 마이페이지에서 선호운동 리스트 UI 개발
    2. 마이페이지 선호운동 리스트 api 연결
    3. 선호운동 선택 스탭 1/2 UI개발
    4. 선호운동 선택가능한 종류 조회 API 연결
    5. 선호운동 선택 스탭 2/2 UI개발
    6. 선호운동 선택 수정,생성 API 연결

[마이페이지](https://www.notion.so/257e8a089aa780319719d40a9e1bbc77?pvs=21)

### 0. 타임 스피너 수정 (3)

[타이머 스피너 리팩토링 회의](https://www.notion.so/26ce8a089aa780508bbceb725c561885?pvs=21) 

공통

- UI/UX 명세서

안드로이드

- 운동 기록 시간 선택 세부 로직
    - 시간 선택 유효성, 캘린더에서 날짜 넘겨받기
- 타이머 시간 선택 UI 수정

프론트

- 운동기록 시간 선택 UI 수정
- 운동 기록 시간 선택 세부 로직
    - 시간 선택 유효성
    - 시간 추월 로직
    - 캘린더에서 날짜 넘겨받기
- 타이머 시간 선택 UI 수정

### 0. 테스트 코드 관련 운다방 리뷰 회의 (Google Design Docs) (1)

- 클라이언트 단위&통합&UI 테스트 → 학습 후 운다방(구글 디자인 문서) 리뷰 에서 발표

### 0. 마케팅 (1)

- 오프라인 소모임에 홍보
- 운동하는 친구들한테 홍보
- 같이 운동할 수 있도록 만들어주고 어플 사용하게 한다.

### 0. 기술부채 (5)

- 프론트
    - 전체 분석하는 방향으로 진행 (오류찾기)
    1. **서비스워커 무한 리로딩으로 인하여 특정 상황에서 페이지가 무한 리로딩 됨**
        - 새로운 버전의 서비스 워커를 재등록 하기 위하여 삽입한 리로드 코드방식의 문제
    - 두번 로그인 해야 메인페이지로 넘어가짐
        - 코그니토 로그인 후 콜백페이지로 돌아올때 세션에 저장된 데이터를 브라우저가 보안상의 문제로 삭제함
- 안드로이드
    - 조회 api 데이터 캐싱
- 백엔드
    - 배치기능 오류 분석 및 해결방안 탐색
    - 회원탈퇴시 재가입 되도록 // null 넣기 (이메일 등 개인정보)

---

---

### 0. 사용자는 지도를 보면서 마음에 드는 사람의 프로필을 확인할 수 있다. (10)

- 클라이언트 (1 + 3 + 3)
    - 지도 구현(카카오 지도 API 연동 + 카카오 주소 연동)
        - 표시(마커)
    - UI/UX회의 및 명세서 작성
    - 회원 운동 장소 관리 페이지
        - 회원 운동 장소 등록/수정/삭제
            - GPS 기반 주소 인증 화면
    - 고정 범위 내 타 회원 리스트 조회 API연결
    - 타 회원 프로필 조회 페이지(마이페이지 or 마이페이지 요약)
        - 작은거 : 클로드에서 나오는 화면(요약한 마이페이지)
        - 큰거 : 마이페이지 양식
- 백엔드 (3)
    - DB / API 설계
    - 다른 회원 프로필 조회 API
    - 회원 운동 주소 등록 API
    - 회원 운동 주소 삭제 API
    - 회원 운동 주소 수정 API
- GPS 기반 주소 인증
- 현재 GPS 주소를 요청으로 받음
- 거리기준 반경 5KM
    - 이 부분에 걸린 회원 리스트 조회

[매칭 기능 관련 회의 [Design Docs]](https://www.notion.so/Design-Docs-26ae8a089aa780c3a06ce28c191a4d28?pvs=21) 

### 0. 오류 해결

1. 자동 로그인 구현 (중) → 운다방리뷰
2. 배포시 자동으로 브라우저 캐시 갱신되도록 개발  (하) → 운다방리뷰

### 0. 안드로이드 앱 무결성 검증 설계 (1)

- 백엔드 : (0.5)
- 안드 : (0.5)

### 운다방 서비스에 불만족한 사용자는 회원탈퇴를 할 수 있다.

### 사용자는 운다방 서비스 이용 중 불편한 점을 개발자에게 알릴 수 있다.

### 매칭

### 사용자는 마이페이지를 통해 자신의 회원 정보(개인 정보) 를 관리 할 수 있다.

### 사용자는 자신의 프로필을 보고 사진도 바꾸고 자기소개도 바꾸고 할 수 있다.

### 공통 (사진 용량 관련)

- 프론트엔드에서 1차 압축으로 사용자 경험을 개선하고, 백엔드에서 2차 검증 및 최종 처리로 데이터 무결성을 보장한다.
1. **(사용자)** 이미지 파일 선택
2. **(프론트엔드)**
    - 사용자가 선택한 이미지가 너무 크면(e.g., 5MB 이상), JS를 이용해 적절한 크기(e.g., 가로 1920px, 2MB 이하)로 **1차 압축**합니다.
    - 이렇게 하면 사용자는 업로드가 빠르다고 느끼게 됩니다.
3. **(업로드)** 1차 압축된 이미지를 서버로 전송합니다.
4. **(백엔드)**
    - 전송받은 이미지가 정말 이미지 파일이 맞는지, 허용된 용량/크기 범위 내에 있는지 **검증**합니다.
    - 프론트엔드 압축을 신뢰하지 않고, 서버의 기준으로 **최종 압축 및 리사이징**을 다시 수행합니다.
    - 이 과정에서 썸네일, 모바일용, PC용 등 **다양한 버전의 이미지를 생성**합니다.
    - 최종 결과물들을 S3와 같은 Object Storage에 저장하고, 데이터베이스에는 해당 이미지들의 경로를 저장합니다.
