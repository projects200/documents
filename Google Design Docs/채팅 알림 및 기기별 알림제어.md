## **채팅 알림 및 기기별 알림 제어 [Google Design Docs]**

## **1. 개요**

본 문서는 기존의 폴링(Polling) 방식 채팅 시스템을 개선하고, 사용자의 실시간 상태 및 기기별/종류별 상세 설정에 따라 조건부로 FCM 푸시 알림을 발송하는 통합 시스템을 설계하는 것을 목표로 한다. 이 프로젝트를 통해 사용자에게는 끊김 없는 채팅 경험과 정제된 알림을 제공하고, 시스템적으로는 향후 확장성과 안정성을 확보하고자 한다.

## **2. 배경 및 동기**

현재 시스템은 두 가지 주요한 문제점을 안고 있다.

첫 번째로 채팅 알림 시스템이 부재하여 중요한 메시지를 놓치기 쉬우며, 만약 구현하더라도 사용자의 현재 채팅방 접속 여부를 고려하지 않으면 무분별한 알림으로 인한 사용자 피로도를 증가시킬 수 있다.

또한, 사용자가 자신의 필요에 맞게 알림을 제어할 수 있는 기능(예: 기기별, 종류별 설정)이 없어 개인화된 경험을 제공하지 못하고 있다. 본 프로젝트는 이러한 문제들을 종합적으로 해결하기 위해 추진된다.

### **2.1. 목표 (Goals)**

1. **조건부 채팅 알림:** 사용자가 특정 채팅방에 접속해 있지 않을 때만 새로운 메시지에 대한 FCM 푸시 알림을 표시한다.
2. **기기별/종류별 알림 설정 기능 제공:** 사용자가 각 디바이스(폰, 태블릿 등)마다 '채팅 알림', '운동 독려 알림' 등 종류별로 알림 수신 여부를 ON/OFF 할 수 있는 기능을 구현한다.
3. **확장 가능한 알림 시스템 구축:** 새로운 알림 유형이 추가될 때 DB 스키마 변경 없이 유연하게 확장 가능한 구조를 설계한다.
4. **프리티어 환경 내 구현:** 외부 유료 서비스나 별도의 서버 인스턴스 추가 없이, Redis 무료 티어(30MB)와 기존 인프라를 최대한 활용하여 시스템을 구축한다.

### **2.2. 비목표 (Non-Goals)**

1. 채팅 시스템을 완전한 실시간(WebSocket/STOMP) 방식으로 즉시 전환하는 것 (본 설계는 향후 전환을 용이하게 하는 기반을 마련하는 데 중점).
2. '읽음' 확인(Read Receipts), '입력 중...'(Typing Indicator)과 같은 고급 실시간 채팅 기능을 구현하는 것.
3. 파일, 이미지 등 미디어 전송 기능 구현.

## **3. 상세 설계 (솔루션 제안)**

조건부 알림 기능을 구현하기 위해 두 가지 모델을 제안한다. 하나는 클라이언트가 상태를 판단하여 알림을 정제하는 모델이고, 다른 하나는 백엔드가 사용자의 실시간 상태를 관리하며 알림을 필터링하는 모델이다.

---

### **3.1. 클라이언트 기반 FCM 알림 필터링 모델**

이 모델은 서버의 역할을 단순화하고, 상태 관리의 최종 책임을 실제 상태의 소유자인 클라이언트에게 위임하는 방식이다. 서버는 사용자의 실시간 채팅방 접속 여부를 알 필요 없이, 알림 조건이 되면 항상 '데이터 메시지(Data Message)' 형식의 푸시를 전송한다.

### **3.1.1. 시스템 아키텍처**

중앙 서버, RDBMS, FCM을 사용하는 구조는 동일하지만, 실시간 상태 관리를 위한 Redis의 역할이 축소 혹은 삭제 된다.

- **RDBMS (MySQL/MariaDB):** 채팅 내용, 사용자 정보, FCM 토큰, 알림 설정 등 모든 영속적 데이터를 저장한다.
- **Redis (Cache) (선택 사항):** 안 읽은 메시지 수 계산 등 여전히 유용하지만, '실시간 접속 상태' 관리를 위한 용도로는 사용되지 않는다.
- **FCM:** 클라이언트에 '데이터 메시지'를 전달한다. 이 메시지는 사용자에게 즉시 보이지 않고, 앱을 백그라운드에서 깨워 로직을 실행시키는 트리거가 된다.

```mermaid
+------------------+      +-------------------------------------------------+
|                  |      |                                                 |
|   Clients        |----->|      Spring Boot Application Server (WAS)       |
| (Android/PWA/Web)|      |  (Business Logic & Unconditional Push Trigger)  |
| - Notification   |      +-------------------------------------------------+
|   Filtering Logic|                   |           |               |
+------------------+                   |           |               |
        ^                              |           |               |
        | (Data Push)                  v           v               v
+------------------+      +----------------+  +----------------+  +----------------+
|                  |      |                |  |                |  |                |
|    FCM Server    |<-----|   RDBMS (DB)   |  |  Redis (Cache) |  |   ... etc ...  |
|     (Google)     |      | - Persistent   |  | - Unread Counts|  |                |
+------------------+      |   Data         |  |   (Optional)   |  |                |
                          +----------------+  +----------------+  +----------------+
```

### **3.1.2. 데이터 모델**

- **RDBMS Schema:** fcm_tokens와 device_notification_settings 테이블 구조는 백엔드 기반 모델과 완전히 동일하다.
- Redis Data Structure: 실시간 상태 관리를 위한 chat:active:users 와 같은 데이터 구조가 더 이상 필요하지 않다. 이로 인해 서버 로직과 인프라 관리가 단순해진다.

### **3.1.3. 핵심 플로우**

1. **메시지 전송 (Client → Server):** 클라이언트가 서버로 메시지 전송을 요청한다.
2. **데이터 저장 및 조회 (Server):** 서버는 메시지를 DB에 저장하고, 해당 채팅방의 멤버(발신자 제외) 중 '채팅 알림'을 받기로 설정한 사용자의 FCM 토큰을 DB에서 조회한다.
3. **데이터 메시지 발송 (Server → FCM → Client):** 서버는 조회된 토큰으로 채팅방 ID, 발신자, 내용 등이 포함된 **데이터 메시지**를 FCM에 발송한다. (이때 사용자의 접속 상태는 고려하지 않는다.)
4. **상태 확인 및 알림 생성 (Client):**
    - 데이터 메시지를 수신한 클라이언트는 자신이 현재 해당 채팅방을 보고 있는지 확인한다.
    - **보고 있다면,** 알림을 무시한다.
    - **보고 있지 않다면,** 수신한 데이터로 **로컬 알림**을 생성하여 사용자에게 보여준다.

> 주요 특징: 채팅방 진입/퇴장 시 서버에 상태를 알리는 API 호출이 불필요하며, 서버는 사용자의 실시간 상태를 관리할 책임이 없다.
> 

---

### **3.2. 백엔드 기반 FCM 알림 필터링 모델**

이 모델은 서버가 Redis를 사용해 모든 사용자의 실시간 접속 상태를 중앙에서 관리하고, 메시지를 보낼 때마다 이 상태를 확인하여 알림 발송 여부를 직접 결정하는 방식이다.

### **3.2.1. 시스템 아키텍처**

애플리케이션 서버는 비즈니스 로직을 처리하며, RDBMS와 Redis에 데이터를 분산 저장/관리한다.

- **RDBMS (MySQL/MariaDB):** 채팅 내용, 사용자 정보, FCM 토큰, 알림 설정 등 모든 영속적 데이터를 저장한다.
- **Redis (Cache):** 사용자의 실시간 상태(채팅방 접속 여부), 안 읽은 메시지 수 등 휘발성이지만 빠른 조회가 필요한 데이터를 저장한다.
- **FCM:** 서버의 판단에 따라 필터링된 사용자에게만 푸시 알림을 발송한다.

```mermaid
+------------------+      +-------------------------------------------------+
|                  |      |                                                 |
|   Clients        |----->|      Spring Boot Application Server (WAS)       |
| (Android/PWA/Web)|      |      (Real-time State & Notification Logic)     |
|                  |      +-------------------------------------------------+
+------------------+                   |           |               |
        ^                              |           |               |
        | (Filtered Push)              v           v               v
+------------------+      +----------------+  +----------------+  +----------------+
|                  |      |                |  |                |  |                |
|    FCM Server    |<-----|   RDBMS (DB)   |  |  Redis (Cache) |  |   ... etc ...  |
|     (Google)     |      | - Persistent   |  | - Ephemeral    |  |                |
+------------------+      |   Data         |  |   State        |  |                |
                          +----------------+  +----------------+  +----------------+
```

### **3.2.2. 데이터 모델**

chatrooms, chatroom_members, chats 외 알림 제어를 위한 2개의 테이블을 추가한다.

```sql
-- 디바이스(FCM 토큰) 정보 관리
CREATE TABLE fcm_tokens (
    fcm_token_id           BIGINT AUTO_INCREMENT PRIMARY KEY,
    member_id              CHAR(36) NOT NULL,
    fcm_token_value        VARCHAR(255) NOT NULL UNIQUE,
    fcm_token_is_active    BOOLEAN NOT NULL DEFAULT TRUE,
    -- ... 기타 메타데이터
);

-- 기기별 상세 알림 설정
CREATE TABLE device_notification_settings (
    setting_id        BIGINT AUTO_INCREMENT PRIMARY KEY,
    fcm_token_id      BIGINT NOT NULL,
    notification_type VARCHAR(50) NOT NULL COMMENT 'CHAT_MESSAGE, BATCH_JOB 등',
    is_enabled        BOOLEAN NOT NULL DEFAULT TRUE,
    UNIQUE KEY uq_token_and_type (fcm_token_id, notification_type),
    CONSTRAINT fk_settings_to_fcm_tokens FOREIGN KEY (fcm_token_id) REFERENCES fcm_tokens (fcm_token_id) ON DELETE CASCADE
);
```

- **Key:** chat:active:users (Hash)
- **Field:** member_id
- **Value:** chatroom_id
- **용도:** 특정 사용자가 현재 어떤 채팅방에 접속해 있는지 O(1)로 조회.

### **3.2.3. 핵심 플로우**

1. **채팅방 진입 (Client → Server):** 사용자가 특정 채팅방에 진입하면, 클라이언트는 서버에 POST /.../enter API를 호출하여 접속 상태를 알린다. 서버는 이 정보를 Redis의 chat:active:users에 기록한다.
2. **메시지 전송 (Client → Server):** 클라이언트가 서버로 메시지 전송을 요청한다.
3. **상태 확인 및 필터링 (Server):**
    - 서버는 메시지를 DB에 저장하고, 해당 채팅방의 다른 멤버들을 조회한다.
    - 각 멤버에 대해 Redis의 chat:active:users를 조회하여 현재 채팅방에 접속 중인지 확인한다.
    - 접속 중이면, 알림 발송 로직을 건너뛴다.
    - 접속 중이 아니면, DB에서 해당 사용자의 FCM 토큰 및 알림 설정을 조회하여 최종 발송 대상 목록에 추가한다.
4. **푸시 알림 발송 (Server → FCM → Client):** 필터링된 최종 대상에게만 FCM 푸시 알림을 발송한다.

> 주요 특징: 채팅방 진입/퇴장 시 반드시 서버에 상태를 알려야 하며, 알림 발송 여부에 대한 모든 판단 책임은 서버에 있다.
> 

## **4. 최종 결론**

본 설계는 사용자의 실시간 알림 기능을 통한 사용자 경험 저해를 막고 개인화된 기기별 알림 제어권을 부여함으로써 채팅 및 알림 기능의 사용자 경험을 극대화하는 것을 목표로 한다. ****클라이언트 필터링 기반 아키텍처는 RDBMS와 Redis의 역할을 명확히 분리하여 각각의 장점을 최대한 활용하며, 특히 분리된 알림 설정 테이블을 통해 향후 비즈니스 요구사항 변화에 유연하게 대처할 수 있는 확장성을 확보한다. 이는 현재의 제약 조건 내에서 가장 효율적인 해결책이 될 것이다.
