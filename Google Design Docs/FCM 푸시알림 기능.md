# FCM 푸시알림 기능 [Google Design Docs]

## FCM 푸시알림 기능 [Google Design Docs]

## 1. 개요

본 문서는 채팅 메시지 수신 시 사용자에게 푸시 알림(FCM)을 전송하는 기능을 설계하는 것을 목표로 합니다. 특히, 사용자가 알림을 탭(tap)했을 때 앱의 메인 화면이 아닌 특정 채팅방으로 직접 이동하는 요구사항을 충족하기 위해 `notification`, `data`, `notification + data` 세 가지 FCM 메시지 페이로드 방식의 장단점을 비교하고, 최종 솔루션을 결정합니다.

## 2. 배경 및 동기

현재 채팅 기능 개발의 일환으로, 앱이 포그라운드, 백그라운드, 또는 종료된 상태에 관계없이 새로운 메시지 수신을 사용자에게 알려야 합니다.

카카오톡과 같은 주요 채팅 앱의 사용자 경험에 따라, 사용자는 수신된 알림을 탭하여 즉시 해당 대화 상대방의 채팅방으로 진입할 수 있어야 합니다. 이 과정이 원활하지 않고 앱의 메인 페이지만 열린다면, 사용자는 다시 해당 채팅방을 찾아 들어가는 불필요한 단계를 거쳐야 하므로 사용자 경험을 저해할 수 있습니다.

따라서 기술적으로 어떤 FCM 페이로드 타입이 이 '채팅방 직접 이동' 요구사항을 가장 안정적으로 지원하는지 명확히 정의할 필요가 있습니다.

### 2.1. 목표 (Goals)

1. 앱의 상태(포그라운드, 백그라운드, 종료)와 관계없이 신규 채팅 메시지 푸시 알림을 수신한다.
2. 사용자가 푸시 알림을 탭하면, 메시지가 발신된 특정 채팅방으로 직접 이동할 수 있어야 한다.
3. 클라이언트에서 알림의 표시 여부 및 내용을 유연하게 제어할 수 있어야 한다.

### 2.2. 비목표 (Non-Goals)

1. 서버 측에서 FCM으로 메시지를 발송하는 API의 상세 구현.

## 3. 상세 설계 (솔루션 제안)

FCM 메시지에는 세 가지 유형이 있으며, 각 유형은 앱의 상태에 따라 다르게 동작합니다. 우리의 핵심 목표인 '채팅방 직접 이동' 요구사항을 기준으로 각 방식을 분석합니다.

### 3-1. Notification 방식

`notification` 키만 포함된 페이로드입니다.

- 동작 방식:
    - 앱 포그라운드: `onMessageReceived` 콜백이 호출되어 알림 데이터를 앱이 직접 처리합니다.
    - 앱 백그라운드/종료: `onMessageReceived`가 호출되지 않습니다. 대신 FCM SDK가 자동으로 시스템 트레이에 알림을 표시합니다.
- 장점: 구현이 가장 간단합니다. 백그라운드일 때 앱의 리소스를 사용하지 않고도 알림이 자동으로 뜹니다.
- 단점:
    1. 백그라운드/종료 상태에서 앱의 `onMessageReceived`가 호출되지 않아, `chatRoomId`와 같은 커스텀 데이터를 수신할 수 없습니다.
    2. 알림을 탭하면 앱의 메인 화면만 실행됩니다. 특정 채팅방으로의 이동이 사실상 불가능합니다.

### 3-2. Data 방식

`data` 키만 포함된 페이로드입니다.

- 동작 방식:
    - 앱 포그라운드: `onMessageReceived` 콜백이 호출됩니다.
    - 앱 백그라운드/종료: `onMessageReceived` 콜백이 항상 호출됩니다.
        - 단, Doze 모드 등 기기 상태에 따라 지연될 수 있음
- 장점:
    1. 앱의 상태와 관계없이 `onMessageReceived`가 항상 호출되므로, `data` 페이로드에 포함된 커스텀 데이터(예: `{"chatRoomId": "12345", "sender": "John"}`)를 앱이 항상 수신하여 제어할 수 있습니다.
    2. 앱 코드 내에서 `chatRoomId`를 기반으로 커스텀 `PendingIntent`를 생성하여 알림을 직접 만들 수 있습니다. 이 `PendingIntent`에 특정 채팅방으로 이동하라는 명시적인 로직을 포함시킬 수 있습니다.
- 단점:
    1. `notification` 방식과 달리, 알림을 표시하는 모든 코드를 클라이언트 앱에서 직접 구현해야 합니다.

### 3-3. Data, Notification 모두 사용하는 방식

`notification`과 `data` 키를 모두 포함하는 페이로드입니다.

- 동작 방식:
    - 앱 포그라운드: `onMessageReceived`가 호출되며, `notification`과 `data` 객체를 모두 수신합니다. (Data 방식과 유사)
    - 앱 백그라운드/종료: `onMessageReceived`가 호출되지 않습니다. `notification` 방식과 동일하게 시스템이 자동으로 알림을 표시합니다.
    - 단, 사용자가 이 알림을 '탭'했을 때만, 런처 액티비티의 `Intent`에 `data` 페이로드의 내용이 'Extra'로 전달됩니다.
- 장점: 간단한 알림은 자동으로 띄우면서, 탭했을 때 부가 데이터를 전달할 수 있습니다.
- 단점:
    1. 백그라운드에서 `onMessageReceived`가 호출되지 않아, 알림이 표시되기 전에 채팅방 이동을 위한 `PendingIntent`를 커스텀할 기회가 없습니다.
    2. 사용자가 알림을 탭하면 앱의 메인 화면이 일단 실행되고, 그 이후에 메인 화면에서 `getIntent().getExtras()`를 통해 데이터를 분석하여 다시 채팅방으로 이동시키는 두번의 페이지 이동을 구현해야 합니다. 이는 UX상 부자연스럽고 구현이 복잡해집니다.

### 

## 4. 최종 결론

목표: "사용자가 알림을 탭하면, 특정 채팅방으로 직접 이동한다."

위 목표를 달성하기 위해, 앱의 상태(포그라운드/백그라운드/종료)에 관계없이 항상 `onMessageReceived` 콜백을 수신하여 커스텀 데이터`chatRoomId, memberId, nickname, content, type`를 처리하고, 이를 기반으로 채팅방 이동 `PendingIntent`를 직접 생성할 수 있어야 합니다.

- `Notification` 방식: 백그라운드에서 커스텀 데이터 처리가 불가능하여 배제.
- `Notification + Data` 방식: 백그라운드에서 `onMessageReceived`가 호출되지 않아, 알림 표시 시점에 페이지 이동 Intent를 커스텀할 수 없어 배제.

따라서, 우리는 Data 방식을 최종 솔루션으로 채택합니다.

서버는 FCM 메시지를 보낼 때 `notification` 객체를 완전히 제거하고, `chatRoomId, memberId, nickname, content, type` 등 필요한 모든 정보를 `data` 객체에 담아 전송해야 합니다. 클라이언트 앱은 `onMessageReceived`에서 이 `data`를 수신하여 `chatRoomId`를 포함한 `PendingIntent`를 생성하고, `NotificationCompat.Builder`를 통해 사용자 정의 알림을 직접 표시합니다.
